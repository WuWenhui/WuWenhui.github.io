{"meta":{"title":"Wenki's Blog","subtitle":"享受生活 善待自己","description":null,"author":"Wenki","url":"https://www.wenkiwu.com"},"pages":[],"posts":[{"title":"使用HTTPS和服务器交互","slug":"how-to-config-https","date":"2018-05-12T04:50:27.000Z","updated":"2018-05-12T04:59:17.252Z","comments":true,"path":"Android/how-to-config-https/","link":"","permalink":"https://www.wenkiwu.com/Android/how-to-config-https/","excerpt":"HTTPS 使用 SSL 在客户端和服务器之间进行加密通信，错误地使用 SSL ，将会导致其它人能够拦截网络上的应用数据。使用一个包含公钥及与其匹配的私钥的证书配置服务器，作为 SSL 客户端与服务器握手的一部分，服务器将通过使用公钥加密签署其证书来证明自己具有私钥。 主机平台一般包含其信任的知名 CA 的列表。从 Android 4.2 开始，Android 包含在每个版本中更新的 100 多个 CA。CA 具有一个证书和一个私钥，为服务器发放证书时，CA 使用其私钥签署服务器证书。然后，客户端可以验证该服务器是否具有平台已知的 CA 发放的证书。","text":"HTTPS 使用 SSL 在客户端和服务器之间进行加密通信，错误地使用 SSL ，将会导致其它人能够拦截网络上的应用数据。使用一个包含公钥及与其匹配的私钥的证书配置服务器，作为 SSL 客户端与服务器握手的一部分，服务器将通过使用公钥加密签署其证书来证明自己具有私钥。 主机平台一般包含其信任的知名 CA 的列表。从 Android 4.2 开始，Android 包含在每个版本中更新的 100 多个 CA。CA 具有一个证书和一个私钥，为服务器发放证书时，CA 使用其私钥签署服务器证书。然后，客户端可以验证该服务器是否具有平台已知的 CA 发放的证书。 如果拥有一个知名 CA 发放证书的服务器，那么可以用以下代码直接发起 HTTPS 请求1234URL url = new URL(\"https://www.wenkiwu.com\");URLConnection urlConnection = url.openConnection();InputStream in = urlConnection.getInputStream();copyInputStreamToOutputStream(in, System.out); 对！就是这么简单。 Android 会对验证证书和主机名做处理，你不用考虑这些细节。 如果验证服务器证书出现 SSLHandshakeException 异常，那么原因可能是颁发服务器证书的 CA 是 Android 系统未知的，或者是自签署的服务器证书。 为了解决证书验证失败的问题，我们可以使用自定义的 TrustManager 使 HttpsURLConnection 信任特定的 CA 。下面示例 使用华盛顿大学的机构 CA1234567891011121314151617181920212223242526272829303132333435// Load CAs from an InputStream// (could be from a resource or ByteArrayInputStream or ...)CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");// From https://www.washington.edu/itconnect/security/ca/load-der.crtInputStream caInput = new BufferedInputStream(new FileInputStream(\"load-der.crt\"));Certificate ca;try &#123; ca = cf.generateCertificate(caInput); System.out.println(\"ca=\" + ((X509Certificate) ca).getSubjectDN());&#125; finally &#123; caInput.close();&#125;// Create a KeyStore containing our trusted CAsString keyStoreType = KeyStore.getDefaultType();KeyStore keyStore = KeyStore.getInstance(keyStoreType);keyStore.load(null, null);keyStore.setCertificateEntry(\"ca\", ca);// Create a TrustManager that trusts the CAs in our KeyStoreString tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);tmf.init(keyStore);// Create an SSLContext that uses our TrustManagerSSLContext context = SSLContext.getInstance(\"TLS\");context.init(null, tmf.getTrustManagers(), null);// Tell the URLConnection to use a SocketFactory from our SSLContextURL url = new URL(\"https://certs.cac.washington.edu/CAtest/\");HttpsURLConnection urlConnection = (HttpsURLConnection)url.openConnection();urlConnection.setSSLSocketFactory(context.getSocketFactory());InputStream in = urlConnection.getInputStream();copyInputStreamToOutputStream(in, System.out); 从 InputStream 获取一个特定的 CA，用该 CA 创建 KeyStore，然后用后者创建和初始化 TrustManager。TrustManager 是系统用于从服务器验证证书的工具，可以使用一个或多个 CA 从 KeyStore 创建，而创建的 TrustManager 将仅信任这些 CA。 很多网站和博客介绍一种如下非常糟糕的解决方案来通过验证123456789101112131415161718192021SSLContext sslContext = SSLContext.getInstance(\"TLS\");sslContext.init(null, new TrustManager[]&#123;new X509TrustManager() &#123; @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; return new X509Certificate[0]; &#125;&#125;&#125;, null);URLConnection urlConnection = url.openConnection();urlConnection.setSSLSocketFactory(sslContext.getSocketFactory());InputStream in = urlConnection.getInputStream();copyInputStreamToOutputStream(in, System.out); 使用一个没有任何作用的 TrustManager。这样做等同于没加密通信，因为任何人都可以在公共 WLAN 热点下，使用伪装成服务器的代理发送数据，通过 DNS 欺骗攻击用户。然后，攻击者可以记录密码和其他个人数据。此方法之所以有效是因为攻击者可以生成一个证书，且没有可以真正验证证书是否来自值得信任的来源的 TrustManager，从而使你的应用可与任何人通信。","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wenkiwu.com/categories/Android/"}],"tags":[{"name":"安全性","slug":"安全性","permalink":"https://www.wenkiwu.com/tags/安全性/"}]},{"title":"Google Protocol Buffer使用","slug":"how-to-using-protobuf","date":"2018-02-04T05:50:27.000Z","updated":"2018-05-12T04:53:04.019Z","comments":true,"path":"Android/how-to-using-protobuf/","link":"","permalink":"https://www.wenkiwu.com/Android/how-to-using-protobuf/","excerpt":"protobuf是一个灵活高效的序列化数据结构的方案，类似XML，但是更小更快更简单。它包含一种用于描述数据结构的接口描述语言和一个用于生成不同编程语言的源代码生成器。通常用于数据交换和数据存储。相比JSON和XML，protobuf拥有以下优点： 数据小：序列化后，数据小3-10倍 速度快：序列化速度快20-100倍 使用简单：proto编译器自动生成数据访问类 加密性：存储和传输的是字节 兼容性好： 不必破坏旧数据格式就可以实现数据结构的更新","text":"protobuf是一个灵活高效的序列化数据结构的方案，类似XML，但是更小更快更简单。它包含一种用于描述数据结构的接口描述语言和一个用于生成不同编程语言的源代码生成器。通常用于数据交换和数据存储。相比JSON和XML，protobuf拥有以下优点： 数据小：序列化后，数据小3-10倍 速度快：序列化速度快20-100倍 使用简单：proto编译器自动生成数据访问类 加密性：存储和传输的是字节 兼容性好： 不必破坏旧数据格式就可以实现数据结构的更新 定义协议格式创建.proto文件，为每个需要序列化的数据结构添加一个message，在每个message中为每一个字段指定名称和类型1234567891011121314151617181920212223242526272829syntax = &quot;proto2&quot;;package tutorial;option java_package = &quot;com.example.tutorial&quot;;option java_outer_classname = &quot;AddressBookProtos&quot;;message Person &#123; required string name = 1; required int32 id = 2; optional string email = 3; enum PhoneType &#123; MOBILE = 0; HOME = 1; WORK = 2; &#125; message PhoneNumber &#123; required string number = 1; optional PhoneType type = 2 [default = HOME]; &#125; repeated PhoneNumber phones = 4;&#125;message AddressBook &#123; repeated Person people = 1;&#125; 生成源文件使用 protobuf 编译器生成java类1protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/file.proto Android Studio使用gradle插件(https://github.com/google/protobuf-gradle-plugin)自动编译.proto文件 创建实例为了构造一个message，你必须首先构造一个构建器，将你想要设置的字段设置为你选择的值，然后调用构建器的build()方法。12345678Person john = Person.newBuilder() .setId(1234) .setName(\"John Doe\") .setEmail(\"jdoe@example.com\") .addPhones(Person.PhoneNumber.newBuilder() .setNumber(\"555-4321\") .setType(Person.PhoneType.HOME)) .build(); 序列化和反序列化 byte[] toByteArray();: 将`message序列化为byte数组 static Person parseFrom(byte[] data);: 从byte数组中解析出message void writeTo(OutputStream output);： 将message序列化到给定的OutputStream中 static Person parseFrom(InputStream input);: 从InputStream中读取并解析成message 更多用法参见官方文档","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wenkiwu.com/categories/Android/"}],"tags":[{"name":"protobuf","slug":"protobuf","permalink":"https://www.wenkiwu.com/tags/protobuf/"}]},{"title":"Android 5.0以上使用MediaProjection跨应用截屏","slug":"cross-application-screenshot-on-Android 5.0+","date":"2018-01-28T03:59:15.000Z","updated":"2018-04-02T13:57:43.761Z","comments":true,"path":"Android/cross-application-screenshot-on-Android 5.0+/","link":"","permalink":"https://www.wenkiwu.com/Android/cross-application-screenshot-on-Android 5.0+/","excerpt":"获取 MediaProjectionManager1mediaProjectionManager = (MediaProjectionManager) getSystemService(Context.MEDIA_PROJECTION_SERVICE); 启动屏幕捕获向用户请求屏幕捕获1startActivityForResult(mediaProjectionManager.createScreenCaptureIntent(), REQUEST_CAPTURE); 获取请求结果12345678@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == REQUEST_CAPTURE) &#123; //申请权限返回结果 mediaProjection = mediaProjectionManager.getMediaProjection(resultCode, data); //... &#125;&#125;","text":"获取 MediaProjectionManager1mediaProjectionManager = (MediaProjectionManager) getSystemService(Context.MEDIA_PROJECTION_SERVICE); 启动屏幕捕获向用户请求屏幕捕获1startActivityForResult(mediaProjectionManager.createScreenCaptureIntent(), REQUEST_CAPTURE); 获取请求结果12345678@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == REQUEST_CAPTURE) &#123; //申请权限返回结果 mediaProjection = mediaProjectionManager.getMediaProjection(resultCode, data); //... &#125;&#125; 获取屏幕内容123456final ImageReader imageReader = ImageReader.newInstance(application.getWidth(), application.getHeight(), PixelFormat.RGBA_8888, 1);virtualDisplay = mediaProjection.createVirtualDisplay(\"capture\", application.getWidth(), application.getHeight(), application.getDpi(), DisplayManager.VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR, imageReader.getSurface(), null, null); 读取屏幕内容1234567891011121314151617Image image = imageReader.acquireLatestImage();if (image == null) &#123; Log.e(TAG, \"imageReader.acquireLatestImage() is null\");&#125; else &#123; Image.Plane plane = image.getPlanes()[0]; int width = image.getWidth(); int height = image.getHeight(); ByteBuffer byteBuffer = plane.getBuffer(); int rowStride = plane.getRowStride(); int pixelStride = plane.getPixelStride(); int rowPadding = rowStride - pixelStride * width; Bitmap bitmap = Bitmap.createBitmap(width + rowPadding / pixelStride, height, Bitmap.Config.ARGB_8888); bitmap.copyPixelsFromBuffer(byteBuffer); bitmap = Bitmap.createBitmap(bitmap, 0, 0, width, height); imageReader.close();&#125; 主要类源代码Application完整代码123456789101112131415161718192021222324252627282930313233343536public class MyApplication extends Application &#123; private MediaProjectionManager mediaProjectionManager; private int width, height, dpi; @Override public void onCreate() &#123; super.onCreate(); this.mediaProjectionManager = (MediaProjectionManager) getSystemServic(Context.MEDIA_PROJECTION_SERVICE); WindowManager manager = (WindowManager) getSystemService(WINDOW_SERVICE); Display display = manager.getDefaultDisplay(); DisplayMetrics displayMetrics = new DisplayMetrics(); display.getMetrics(displayMetrics); width = displayMetrics.widthPixels; height = displayMetrics.heightPixels; dpi = displayMetrics.densityDpi; &#125; public MediaProjectionManager getMediaProjectionManager() &#123; return mediaProjectionManager; &#125; public int getWidth() &#123; return width; &#125; public int getHeight() &#123; return height; &#125; public int getDpi() &#123; return dpi; &#125;&#125; MainActivity完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class MainActivity extends AppCompatActivity &#123; public static final String TAG = MainActivity.class.getSimpleName(); public static final int REQUEST_CAPTURE = 1001; MyApplication application = null; Handler mHandler = new Handler(); ImageView imageView = null; MediaProjectionManager mediaProjectionManager = null; MediaProjection mediaProjection = null; VirtualDisplay virtualDisplay = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); application = (MyApplication) getApplication(); imageView = findViewById(R.id.imageView); //申请录屏权限 mediaProjectionManager = application.getMediaProjectionManager(); startActivityForResult(mediaProjectionManager.createScreenCaptureIntent(), REQUEST_CAPTURE); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == REQUEST_CAPTURE) &#123; //申请录屏权限返回结果 mediaProjection = mediaProjectionManager.getMediaProjection(resultCode, data); if(mediaProjection != null) &#123; saveCapture(); &#125;else&#123; Log.e(TAG, \"acquire ScreenCapture fail\"); &#125; &#125; &#125; private void saveCapture() &#123; final ImageReader imageReader = ImageReader.newInstance(application.getWidth(), application.getHeight(), PixelFormat.RGBA_8888, 1); virtualDisplay = mediaProjection.createVirtualDisplay(\"capture\", application.getWidth(), application.getHeight(), application.getDpi(), DisplayManager.VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR, imageReader.getSurface(), null, null); mHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; Image image = imageReader.acquireLatestImage(); if (image == null) &#123; Log.e(TAG, \"imageReader.acquireLatestImage() is null\"); &#125; else &#123; Image.Plane plane = image.getPlanes()[0]; int width = image.getWidth(); int height = image.getHeight(); ByteBuffer byteBuffer = plane.getBuffer(); int rowStride = plane.getRowStride(); int pixelStride = plane.getPixelStride(); int rowPadding = rowStride - pixelStride * width; Bitmap bitmap = Bitmap.createBitmap(width + rowPadding / pixelStride, height, Bitmap.Config.ARGB_8888); bitmap.copyPixelsFromBuffer(byteBuffer); bitmap = Bitmap.createBitmap(bitmap, 0, 0, width, height); imageReader.close(); //可将bitmap保存到本地 imageView.setImageBitmap(bitmap); &#125; &#125; &#125;, 500); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); virtualDisplay.release(); mediaProjection.stop(); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wenkiwu.com/categories/Android/"}],"tags":[{"name":"截屏","slug":"截屏","permalink":"https://www.wenkiwu.com/tags/截屏/"}]},{"title":"使用GitHub Pages部署个人网站","slug":"using-GithubPages-deploy-personal-site","date":"2018-01-20T09:20:32.000Z","updated":"2018-04-02T14:00:13.705Z","comments":true,"path":"建站/using-GithubPages-deploy-personal-site/","link":"","permalink":"https://www.wenkiwu.com/建站/using-GithubPages-deploy-personal-site/","excerpt":"GitHub Pages前往GitHub官网，登录或注册账号新建仓库，仓库名为yourname.github.io。其中yourname填写你的GitHub账户名，创建成功后，GitHub会自动为你开启Github pages Hexo部署使用Hexo建站完成并测试后，即可发布到github。","text":"GitHub Pages前往GitHub官网，登录或注册账号新建仓库，仓库名为yourname.github.io。其中yourname填写你的GitHub账户名，创建成功后，GitHub会自动为你开启Github pages Hexo部署使用Hexo建站完成并测试后，即可发布到github。 修改_config_yml文件12345deploy: type: git repo: https://github.com/yourname/yourname.github.io.git branch: master message: commit message 参数 描述 repo GitHub仓库URL branch 提交到哪个分支(可选) message 自定义提交信息(可选) 安装hexo-deployer-git模块1&gt; npm install hexo-deployer-git --save 部署12&gt; hexo generate&gt; hexo deploy 也可简写成hexo g -d或hexo d -g 部署完成后，即可访问 https://yourname.github.io/ 查看你的个人网站了 自定义域名GitHub Pages允许为网站绑定自己的域名，替代 yourname.github.io 作为网站的访问地址。 在Hexo网站项目的source目录下新建文件CNAME，写入你的域名，如:1www.wenkiwu.com 修改完成后部署 前往域名注册商添加解析记录 主机记录 记录类型 记录值 www CNAME yourname.github.io @ CNAME yourname.github.io 设置完成后等待生效 将网站源文件使用git管理在github上创建仓库 进入网站项目根目录，执行下面命令12345&gt; git init&gt; git remote add origin [repository url]&gt; git add .&gt; git commit -m &apos;message&apos;&gt; git push --set-upstream origin master 在其它电脑上就可获取项目源文件修改并部署1$ git clone [repository url] 进入项目根目录，此电脑已有nodejs并安装hexo的情况下12$ npm install$ npm install hexo-deployer-git --save 新建文件或者修改项目，测试后部署1$ hexo d -g 将更改提交到远程仓库1$ git push origin master","categories":[{"name":"建站","slug":"建站","permalink":"https://www.wenkiwu.com/categories/建站/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.wenkiwu.com/tags/hexo/"},{"name":"GitHub Pages","slug":"GitHub-Pages","permalink":"https://www.wenkiwu.com/tags/GitHub-Pages/"}]},{"title":"Hexo搭建个人网站","slug":"using-hexo-build-personal-site","date":"2018-01-20T07:16:55.000Z","updated":"2018-04-02T14:02:02.157Z","comments":true,"path":"建站/using-hexo-build-personal-site/","link":"","permalink":"https://www.wenkiwu.com/建站/using-hexo-build-personal-site/","excerpt":"nodejs和npm安装前往Node.js下载页下载最新的LTS版本。 按步骤安装Node.js，注意选择安装 npm package manager 和 Ad to PATH。 使用 npm -v 测试是否已成功安装","text":"nodejs和npm安装前往Node.js下载页下载最新的LTS版本。 按步骤安装Node.js，注意选择安装 npm package manager 和 Ad to PATH。 使用 npm -v 测试是否已成功安装 Hexo安装使用npm安装Hexo1&gt; npm install -g hexo-cli 如果觉得安装模块太慢，可设置淘宝NPM镜像1&gt; npm config set registry https://registry.npm.taobao.org 建站初始化目录安装完成后，前往项目文件夹执行命令123&gt; cd D:\\HexoPages&gt; hexo init&gt; npm install 完成后，文件夹目录大致有 scaffolds 模板文件夹。新建文章时，Hexo会根据此文件夹中的文件，在新建的markdown文件中默认填充内容 source 资源文件夹。存放用户资源的地方 themes 主题文件夹。Hexo会根据主题来生成静态页面 .gitignore Git版本控制配置文件 _config.yml 网站配置文件 package.json 应用程序配置信息 新建文件hexo new [layout] &lt;title&gt; 命令用于使用指定布局新建文章，layout 用于指定文章的布局，默认是post。Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件1&gt; hexo new hello Hexo 默认以标题作为文件的名称，也可通过 _config.yml 的 new_post_name 参数来修改默认的文件名称 生成静态文件1&gt; hexo generate 启动服务器安装hexo-server1&gt; npm install hexo-server --save 安装完成后启动服务器，默认使用4000端口，使用-p指定端口1&gt; hexo server -p 4001","categories":[{"name":"建站","slug":"建站","permalink":"https://www.wenkiwu.com/categories/建站/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.wenkiwu.com/tags/hexo/"}]},{"title":"Android 7.0 使用 FileProvider 共享文件","slug":"android 7.0-fileprovider-uri","date":"2017-02-07T06:36:23.000Z","updated":"2018-05-14T15:13:40.607Z","comments":true,"path":"Android/android 7.0-fileprovider-uri/","link":"","permalink":"https://www.wenkiwu.com/Android/android 7.0-fileprovider-uri/","excerpt":"对于面向 Android 7.0 的应用，Android 框架执行的 StrictMode API 政策禁止在您的应用外部公开 file:// URI。如果一项包含文件 URI 的 intent 离开您的应用，则应用出现故障，并出现 FileUriExposedException 异常。 要在应用间共享文件，您应发送一项 content:// URI，并授予 URI 临时访问权限。进行此授权的最简单方式是使用 FileProvider 类。 如下载apk安装包后，调用安装器自动安装apk 以前用以下代码即可安装下载在本地的apk文件(apkFile)1234Intent intent = new Intent();intent.setAction(Intent.ACTION_VIEW);intent.setDataAndType(Uri.fromFile(apkFile), \"application/vnd.android.package-archive\");startActivity(intent);","text":"对于面向 Android 7.0 的应用，Android 框架执行的 StrictMode API 政策禁止在您的应用外部公开 file:// URI。如果一项包含文件 URI 的 intent 离开您的应用，则应用出现故障，并出现 FileUriExposedException 异常。 要在应用间共享文件，您应发送一项 content:// URI，并授予 URI 临时访问权限。进行此授权的最简单方式是使用 FileProvider 类。 如下载apk安装包后，调用安装器自动安装apk 以前用以下代码即可安装下载在本地的apk文件(apkFile)1234Intent intent = new Intent();intent.setAction(Intent.ACTION_VIEW);intent.setDataAndType(Uri.fromFile(apkFile), \"application/vnd.android.package-archive\");startActivity(intent); 现在则需要使用 FileProvider.getUriForFile 来传入文件路径 在 res 文件夹下创建 xml 子文件夹（如果已存在，忽略），并新建文件 provider_paths.xml ，写入下面内容1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;paths&gt; &lt;external-path path=\".\" name=\"external_files\"/&gt;&lt;/paths&gt; 接下来在 AndroidManifest.xml 的 &lt;application&gt; 标签内添加 &lt;provider&gt;123456789&lt;provider android:name=\"android.support.v4.content.FileProvider\" android:authorities=\"$&#123;APPLICATION_ID&#125;.provider\" android:exported=\"false\" android:grantUriPermissions=\"true\"&gt; &lt;meta-data android:name=\"android.support.FILE_PROVIDER_PATHS\" android:resource=\"@xml/provider_paths\"/&gt;&lt;/provider&gt; 12345Intent intent = new Intent();intent.setAction(Intent.ACTION_VIEW);Uri apkUri = FileProvider.getUriForFile(context, BuildConfig.APPLICATION_ID + \".provider\", apkFile);intent.setDataAndType(apkUri, \"application/vnd.android.package-archive\");startActivity(intent); 注意：当使用 FileProvider.getUriForFile 传入Uri时，如报异常12java.lang.SecurityException: Permission Denial: writing android.support.v4.content.FileProvider uri ... 则需要调用 grantUriPermission(String toPackage, Uri uri, int modeFlags) 授予Uri的访问权限","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wenkiwu.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wenkiwu.com/tags/Android/"}]},{"title":"Android 6.0 后 权限申请","slug":"android 6.0-request-permissions","date":"2016-10-23T08:41:27.000Z","updated":"2018-05-14T15:17:08.541Z","comments":true,"path":"Android/android 6.0-request-permissions/","link":"","permalink":"https://www.wenkiwu.com/Android/android 6.0-request-permissions/","excerpt":"Android 6.0在我们原有的AndroidManifest.xml声明权限的基础上，又新增了运行时权限动态检测。 以下权限都需要在运行时判断：1身体传感器，日历，摄像头，通讯录，地理位置，麦克风，电话，短信，存储空间 Android6.0 系统默认为 targetSdkVersion 小于 23 的应用默认授予了所申请的所有权限，所以如果你以前的APP设置的 targetSdkVersion 低于23，在运行时也不会崩溃，但这也只是一个临时的救急策略，用户还是可以在设置中取消授予的权限。","text":"Android 6.0在我们原有的AndroidManifest.xml声明权限的基础上，又新增了运行时权限动态检测。 以下权限都需要在运行时判断：1身体传感器，日历，摄像头，通讯录，地理位置，麦克风，电话，短信，存储空间 Android6.0 系统默认为 targetSdkVersion 小于 23 的应用默认授予了所申请的所有权限，所以如果你以前的APP设置的 targetSdkVersion 低于23，在运行时也不会崩溃，但这也只是一个临时的救急策略，用户还是可以在设置中取消授予的权限。 检查并申请权限我们需要在用到权限的地方，每次都检查是否APP已经拥有权限，比如我们有一个下载功能，需要写SD卡的权限，我们在写入之前检查是否有 WRITE_EXTERNAL_STORAGE 权限，没有则申请权限123456if (ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; //申请WRITE_EXTERNAL_STORAGE权限 ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, WRITE_EXTERNAL_STORAGE_REQUEST_CODE);&#125; 请求权限后，系统会弹出请求权限的Dialog 授权结果处理用户选择允许或需要后，会回调 onRequestPermissionsResult 方法, 该方法类似于 onActivityResult12345@Overridepublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); doNext(requestCode,grantResults);&#125; 我们接着需要根据 requestCode 和 grantResults (授权结果)做相应的后续处理123456789private void doNext(int requestCode, int[] grantResults) &#123; if (requestCode == WRITE_EXTERNAL_STORAGE_REQUEST_CODE) &#123; if (grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; // Permission Granted &#125; else &#123; // Permission Denied &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wenkiwu.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wenkiwu.com/tags/Android/"}]},{"title":"Android 切换 Fragment 时不重新实例化","slug":"android-switch-frangment","date":"2016-05-09T06:41:31.000Z","updated":"2018-05-14T15:16:59.953Z","comments":true,"path":"Android/android-switch-frangment/","link":"","permalink":"https://www.wenkiwu.com/Android/android-switch-frangment/","excerpt":"以前实现 Fragment 的切换都是用 replace 方法实现123456public void startFragmentAdd(Fragment fragment) &#123; FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); fragmentTransaction.replace(R.id.main_layout, fragment, fragment.getClass().getName()) .commit();&#125; replace() 方法只是在上一个 Fragment 不再需要时采用的简便方法。因此，每次切换的时候，Fragment 都会重新实例化，重新加载数据。如果要实现 Fragment 切换时不重新实例化，正确的切换方式是 add() ，切换时 hide() 当前，add() 另一个 Fragment；再次切换时，只需 hide() 当前，show() 另一个。","text":"以前实现 Fragment 的切换都是用 replace 方法实现123456public void startFragmentAdd(Fragment fragment) &#123; FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); fragmentTransaction.replace(R.id.main_layout, fragment, fragment.getClass().getName()) .commit();&#125; replace() 方法只是在上一个 Fragment 不再需要时采用的简便方法。因此，每次切换的时候，Fragment 都会重新实例化，重新加载数据。如果要实现 Fragment 切换时不重新实例化，正确的切换方式是 add() ，切换时 hide() 当前，add() 另一个 Fragment；再次切换时，只需 hide() 当前，show() 另一个。1234567891011121314151617181920212223// fragment的切换private void startFragmentAdd(Fragment fragment) &#123; FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager .beginTransaction(); if (current_fragment == null) &#123; fragmentTransaction.add(R.id.main_layout, fragment).commit(); current_fragment = fragment; &#125; if (current_fragment != fragment) &#123; // 先判断是否被add过 if (!fragment.isAdded()) &#123; // 隐藏当前的fragment，add下一个到Activity中 fragmentTransaction.hide(current_fragment) .add(R.id.main_layout, fragment).commit(); &#125; else &#123; // 隐藏当前的fragment，显示下一个 fragmentTransaction.hide(current_fragment).show(fragment) .commit(); &#125; current_fragment = fragment; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wenkiwu.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wenkiwu.com/tags/Android/"}]},{"title":"Android如何做到应用程序图标隐藏，并由第三方程序启动","slug":"lauch-app-in-other-app","date":"2015-09-13T07:32:28.000Z","updated":"2018-05-14T15:16:43.173Z","comments":true,"path":"Android/lauch-app-in-other-app/","link":"","permalink":"https://www.wenkiwu.com/Android/lauch-app-in-other-app/","excerpt":"隐藏应用程序的启动图标在App的 AndroidManifest.xml 中，将启动页的 intent-filter 做如下修改1234&lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt;&lt;/intent-filter&gt; 第三方程序启动App1234Intent intent = new Intent(Intent.ACTION_MAIN);intent.setComponent(new ComponentName(\"com.test.app\", \"com.test.app.MainActivity\"));intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);startActivity(intent); 其中 com.test.app 为应用程序包名，而 com.test.app.MainActivity 为你所要启动的第一个Activity，即上面所指的启动页","text":"隐藏应用程序的启动图标在App的 AndroidManifest.xml 中，将启动页的 intent-filter 做如下修改1234&lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt;&lt;/intent-filter&gt; 第三方程序启动App1234Intent intent = new Intent(Intent.ACTION_MAIN);intent.setComponent(new ComponentName(\"com.test.app\", \"com.test.app.MainActivity\"));intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);startActivity(intent); 其中 com.test.app 为应用程序包名，而 com.test.app.MainActivity 为你所要启动的第一个Activity，即上面所指的启动页 如果你不知道启动页，或者你的启动页会变化，那么你也可以如下调用123456789101112131415161718192021public boolean startApp(String packageName) &#123; Intent intent = new Intent(Intent.ACTION_MAIN, null); intent.addCategory(Intent.CATEGORY_DEFAULT); PackageManager pm = getPackageManager(); List&lt;ResolveInfo&gt; listInfos = pm.queryIntentActivities(intent, 0); String className = null; for (ResolveInfo info : listInfos) &#123; if (packageName.equals(info.activityInfo.packageName)) &#123; className = info.activityInfo.name; break; &#125; &#125; if (className != null &amp;&amp; className.length() &gt; 0) &#123; intent.setComponent(new ComponentName(packageName, className)); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED); startActivity(intent); return true; &#125; return false;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://www.wenkiwu.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://www.wenkiwu.com/tags/Android/"}]}]}